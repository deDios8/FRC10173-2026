from phoenix6 import CANBus, configs, hardware, signals, swerve, units
from subsystems.command_swerve_drivetrain import CommandSwerveDrivetrain
from wpimath.units import inchesToMeters


class TunerConstants:
    """
    Generated by the Tuner X Swerve Project Generator
    https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html
    """

    # Both sets of gains need to be tuned to your individual robot

    # The steer motor uses any SwerveModule.SteerRequestType control request with the
    # output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput
    _steer_gains = (
        configs.Slot0Configs()
        .with_k_p(50)
        .with_k_i(0)
        .with_k_d(0.1)
        .with_k_s(0.0)
        .with_k_v(0.1)
        .with_k_a(0)
        .with_static_feedforward_sign(signals.StaticFeedforwardSignValue.USE_CLOSED_LOOP_SIGN)
    )
    # When using closed-loop control, the drive motor uses the control
    # output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput
    _drive_gains = (
        configs.Slot0Configs()
        .with_k_p(0.1)
        .with_k_i(0)
        .with_k_d(0)
        .with_k_s(0)
        .with_k_v(0.124)
    )

    # The closed-loop output type to use for the steer and drive motors;
    # This affects the PID/FF gains for the steer and drive motors
    _steer_closed_loop_output = swerve.ClosedLoopOutputType.VOLTAGE
    _drive_closed_loop_output = swerve.ClosedLoopOutputType.VOLTAGE

    # The type of motor used for the drive and steer motor
    _drive_motor_type = swerve.DriveMotorArrangement.TALON_FX_INTEGRATED
    _steer_motor_type = swerve.SteerMotorArrangement.TALON_FX_INTEGRATED

    # The remote sensor feedback type to use for the steer motors;
    # When not Pro-licensed, Fused*/Sync* automatically fall back to Remote*
    _steer_feedback_type = swerve.SteerFeedbackType.FUSED_CANCODER

    # The stator current at which the wheels start to slip;
    # This needs to be tuned to your individual robot
    _slip_current: units.ampere = 120.0

    # Initial configs for the drive and steer motors and the azimuth encoder; these cannot be null.
    # Some configs will be overwritten; check the `with_*_initial_configs()` API documentation.
    _drive_initial_configs = configs.TalonFXConfiguration()
    _steer_initial_configs = configs.TalonFXConfiguration().with_current_limits(
        configs.CurrentLimitsConfigs()
        # Swerve azimuth does not require much torque output, so we can set a relatively low
        # stator current limit to help avoid brownouts without impacting performance.
        .with_stator_current_limit(60.0)
        .with_stator_current_limit_enable(True)
    )
    _encoder_initial_configs = configs.CANcoderConfiguration()
    # Configs for the Pigeon 2; leave this None to skip applying Pigeon 2 configs
    _pigeon_configs: configs.Pigeon2Configuration | None = None

    # CAN bus that the devices are located on;
    # All swerve devices must share the same CAN bus
    canbus = CANBus("DriveTrainCANivore", "./logs/example.hoot")

    # Theoretical free speed (m/s) at 12 V applied output;
    # This needs to be tuned to your individual robot
    speed_at_12_volts: units.meters_per_second = 5.41

    # Every 1 rotation of the azimuth results in _couple_ratio drive motor turns;
    # This may need to be tuned to your individual robot
    _couple_ratio = 3.125

    _drive_gear_ratio = 5.902777777777778
    _steer_gear_ratio = 12.8
    _wheel_radius: units.meter = inchesToMeters(2.167)

    _invert_left_side = False
    _invert_right_side = True

    _pigeon_id = 12

    # These are only used for simulation
    _steer_inertia: units.kilogram_square_meter = 0.01
    _drive_inertia: units.kilogram_square_meter = 0.01
    # Simulated voltage necessary to overcome friction
    _steer_friction_voltage: units.volt = 0.2
    _drive_friction_voltage: units.volt = 0.2

    drivetrain_constants = (
        swerve.SwerveDrivetrainConstants()
        .with_can_bus_name(canbus.name)
        .with_pigeon2_id(_pigeon_id)
        .with_pigeon2_configs(_pigeon_configs)
    )

    _constants_creator: swerve.SwerveModuleConstantsFactory[configs.TalonFXConfiguration, configs.TalonFXConfiguration, configs.CANcoderConfiguration] = (
        swerve.SwerveModuleConstantsFactory()
        .with_drive_motor_gear_ratio(_drive_gear_ratio)
        .with_steer_motor_gear_ratio(_steer_gear_ratio)
        .with_coupling_gear_ratio(_couple_ratio)
        .with_wheel_radius(_wheel_radius)
        .with_steer_motor_gains(_steer_gains)
        .with_drive_motor_gains(_drive_gains)
        .with_steer_motor_closed_loop_output(_steer_closed_loop_output)
        .with_drive_motor_closed_loop_output(_drive_closed_loop_output)
        .with_slip_current(_slip_current)
        .with_speed_at12_volts(speed_at_12_volts)
        .with_drive_motor_type(_drive_motor_type)
        .with_steer_motor_type(_steer_motor_type)
        .with_feedback_source(_steer_feedback_type)
        .with_drive_motor_initial_configs(_drive_initial_configs)
        .with_steer_motor_initial_configs(_steer_initial_configs)
        .with_encoder_initial_configs(_encoder_initial_configs)
        .with_steer_inertia(_steer_inertia)
        .with_drive_inertia(_drive_inertia)
        .with_steer_friction_voltage(_steer_friction_voltage)
        .with_drive_friction_voltage(_drive_friction_voltage)
    )


    # Common offsets and inversion settings
    x_pos_from_center = inchesToMeters(13.5)
    y_pos_from_center = inchesToMeters(10.75)
    common_drive_motor_inverted = False
    common_steer_motor_inverted = False
    common_encoder_inverted = False
    
    # Module configurations
    modules = {
        "front_left": {
            "drive_motor_id": 3,
            "steer_motor_id": 4,
            "encoder_id": 5,
            "encoder_offset": 0.07421875, # units.rotation
            "x_pos": x_pos_from_center,
            "y_pos": y_pos_from_center,
        },
        "front_right": {
            "drive_motor_id": 0,
            "steer_motor_id": 1,
            "encoder_id": 2,
            "encoder_offset": -0.178466796875,
            "x_pos": x_pos_from_center,
            "y_pos": -y_pos_from_center,
        },
        "back_left": {
            "drive_motor_id": 6,
            "steer_motor_id": 7,
            "encoder_id": 8,
            "encoder_offset": -0.011962890625,
            "x_pos": -x_pos_from_center,
            "y_pos": y_pos_from_center,
        },
        "back_right": {
            "drive_motor_id": 9,
            "steer_motor_id": 10,
            "encoder_id": 11,
            "encoder_offset": 0.4169921875,
            "x_pos": -x_pos_from_center,
            "y_pos": -y_pos_from_center,
        },
    }
    
    # Create constants for each module
    module_constants = {}
    for name, config in modules.items():
        module_constants[name] = _constants_creator.create_module_constants(
            config["steer_motor_id"],
            config["drive_motor_id"],
            config["encoder_id"],
            config["encoder_offset"],
            config["x_pos"],
            config["y_pos"],
            common_drive_motor_inverted,
            common_steer_motor_inverted,
            common_encoder_inverted,
        )
    
    # Unpack constants for direct access
    front_left = module_constants["front_left"]
    front_right = module_constants["front_right"]
    back_left = module_constants["back_left"]
    back_right = module_constants["back_right"]

    @classmethod
    def create_drivetrain(cls) -> CommandSwerveDrivetrain:
        """
        Creates a CommandSwerveDrivetrain instance.
        This should only be called once in your robot program.
        """
        return CommandSwerveDrivetrain(
            hardware.TalonFX,
            hardware.TalonFX,
            hardware.CANcoder,
            cls.drivetrain_constants,
            [
                cls.front_left,
                cls.front_right,
                cls.back_left,
                cls.back_right,
            ],
        )
